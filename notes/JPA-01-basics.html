<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>JPA 기본 개념 — spring-jpa.dev</title>
  <link rel="stylesheet" href="/styles.css" />
</head>
<body>
  <header class="site-header container">
    <a class="brand" href="/">spring-jpa.dev</a>
    <nav class="nav">
      <a href="/projects/">Projects</a>
      <a class="active" href="/notes/">Notes</a>
    </nav>
  </header>

  <main class="container article">
    <!-- 좌측: 자동 생성 목차 -->
    <aside class="toc" aria-label="Table of contents">
      <div class="toc-title">목차</div>
      <ul id="toc-list"></ul>
    </aside>

    <!-- 우측: 글 본문 -->
    <article class="prose">
      <h1>JPA 기본 개념 정리</h1>
      <p class="muted">작성일 2025-08-01 · 분류: Spring Boot, JPA</p>

      <!-- 1. 개요 -->
      <h2 class="section">개요</h2>
      <p>JPA(Java Persistence API)는 자바 진영의 ORM 표준. 객체지향 모델과 관계형 데이터베이스 사이의 간극을 줄여준다.
         내 목표는 “SQL을 안 쓰는 것”이 아니라, <i>객체 모델을 우선 설계</i>하고 JPA가 SQL 생성을 도와주게 만드는 것.</p>
      <ul>
        <li>이번 글: 엔티티/컬럼 매핑, 식별자 전략, 영속성 컨텍스트, 플러시, 생명주기.</li>
        <li>다음 글: 연관관계 매핑, 로딩 전략, Spring Data JPA, QueryDSL.</li>
      </ul>

      <div class="callout muted">
        <p><b>이미지/폴더 규칙</b> · 이번 챕터 스냅샷은 <code>/assets/notes/jpa/basics/</code>에 둔다. 
        파일명은 <code>SNAPSHOT-XX-설명.png</code> 형식으로 관리.</p>
      </div>

      <!-- 2. 왜 JPA인가 -->
      <h2 class="section">왜 JPA인가</h2>
      <p>ORM을 쓰는 이유: 도메인 모델을 중심으로 생각할 수 있고, 반복적인 CRUD SQL을 줄일 수 있다. 
         반대로 ORM이 만능은 아니다. 복잡한 리포트성 쿼리, 대량 벌크 작업은 여전히 JPQL/네이티브가 편할 때가 많았다.</p>
      <ul>
        <li><b>장점</b>: 변경 감지, 쓰기 지연, 캐싱으로 생산성↑. 동일성 보장으로 객체 그래프 일관성↑.</li>
        <li><b>주의</b>: 무분별한 EAGER, 무심코 양방향 남발, 트랜잭션 경계 밖 지연 로딩 → 문제의 근원.</li>
      </ul>

      <!-- 3. 엔티티 매핑 -->
      <h2 class="section">엔티티 매핑</h2>
      <p>클래스에 <code>@Entity</code>를 붙이면 JPA가 관리 대상이 된다. 테이블명·제약은 <code>@Table</code>로 지정.
         기본 생성자는 필수(프록시/프레임워크용).</p>

      <!-- 이미지 자리 -->
      <figure class="figure">
        <img src="/assets/notes/jpa/basics/SNAPSHOT-01-entity.png" alt="엔티티 매핑 예시">
        <figcaption>엔티티 매핑 기본 (SNAPSHOT-01-entity.png)</figcaption>
      </figure>

      <p>내 경험상, 비즈니스 키를 PK로 쓰면 요구사항이 바뀔 때 곤란했다. 대리 키(Long)로 두고 비즈니스 키는 유니크 인덱스로 관리하는 편이 안전했다.</p>

      <!-- 4. 식별자 전략 -->
      <h2 class="section">식별자 전략</h2>
      <p>JPA는 <code>AUTO / IDENTITY / SEQUENCE / TABLE</code> 전략을 제공한다. 데이터베이스와 배치 패턴에 맞춰 선택한다.</p>
      <ul>
        <li><b>IDENTITY</b> (MySQL 등): DB가 PK를 생성. 간편하지만 <i>배치 INSERT</i>와 상성이 안 좋을 수 있음.</li>
        <li><b>SEQUENCE</b> (PostgreSQL/Oracle): 시퀀스로 PK 선점 가능. <code>allocationSize</code>로 성능 조절.</li>
        <li><b>TABLE</b>: 별도 키 전용 테이블. 호환성↑, 성능↓.</li>
      </ul>

      <figure class="figure">
        <img src="/assets/notes/jpa/basics/SNAPSHOT-02-id-strategy.png" alt="식별자 전략 비교">
        <figcaption>식별자 전략: 배치/성능 관점에서 선택 (SNAPSHOT-02-id-strategy.png)</figcaption>
      </figure>

      <p>대량 저장이 많다면 SEQUENCE + <code>allocationSize</code> 조정이 효과적이었다.</p>

      <!-- 5. 필드·컬럼 매핑 -->
      <h2 class="section">필드와 컬럼 매핑</h2>
      <ul>
        <li><code>@Column</code> — 컬럼명, 길이, null 정책 등.</li>
        <li><code>@Enumerated(EnumType.STRING)</code> — 반드시 STRING. ORDINAL은 순서 바뀌면 깨진다.</li>
        <li><code>@Lob</code> — 긴 텍스트/바이너리.</li>
        <li><code>@Transient</code> — DB 비매핑(계산 필드 등).</li>
      </ul>
      <p>반복되는 속성은 값 타입으로 뽑아내면 깔끔하다. 임베디드는 특히 주소/기간 같은 공통 도메인에 유용했다.</p>

      <figure class="figure">
        <img src="/assets/notes/jpa/basics/SNAPSHOT-03-embedded.png" alt="임베디드 값 타입">
        <figcaption>임베디드 값 타입 (SNAPSHOT-03-embedded.png)</figcaption>
      </figure>

      <!-- 6. 영속성 컨텍스트 -->
      <h2 class="section">영속성 컨텍스트</h2>
      <p>영속성 컨텍스트는 “1차 캐시 + 변경 추적” 저장소다. 같은 트랜잭션에서 같은 식별자는 같은 객체를 돌려준다(동일성 보장).</p>
      <ul>
        <li><b>동일성</b> — <code>em.find()</code> 두 번 호출해도 같은 객체.</li>
        <li><b>변경 감지</b> — 커밋/플러시 시 스냅샷과 비교해 달라진 필드만 UPDATE.</li>
        <li><b>쓰기 지연</b> — SQL을 모았다가 플러시 타이밍에 보낸다.</li>
      </ul>

      <figure class="figure">
        <img src="/assets/notes/jpa/basics/SNAPSHOT-04-dirty-check.png" alt="Dirty Checking 예시">
        <figcaption>Dirty Checking: 세터만으로 UPDATE (SNAPSHOT-04-dirty-check.png)</figcaption>
      </figure>

      <p>여기서 중요한 건 트랜잭션 경계 안에서만 동작한다는 점. 경계 밖에서는 변경 감지가 일어나지 않는다.</p>

      <!-- 7. 플러시(Flush) -->
      <h2 class="section">플러시(Flush)</h2>
      <p>플러시는 “SQL 전송”이다. 1차 캐시는 그대로 남고, 변경 사항만 DB로 보낸다. 커밋과 동일시하면 헷갈린다.</p>
      <ul>
        <li>자동: 트랜잭션 커밋, JPQL 실행 직전.</li>
        <li>수동: <code>em.flush()</code> — 테스트/배치에서 타이밍 조절용.</li>
      </ul>

      <p>IDENTITY 전략은 DB에서 키를 즉시 받아와야 해서 대량 INSERT 최적화가 제한적이었다. SEQUENCE 계열이면 <code>allocationSize</code>로 완충 가능.</p>

      <!-- 8. 엔티티 생명주기 -->
      <h2 class="section">엔티티 생명주기</h2>
      <p>JPA가 관리하는 상태 전이는 네 가지로 요약된다. 상태를 정확히 알아야 “왜 여기서 지연 로딩이 터지지?”를 빠르게 파악한다.</p>
      <ul>
        <li><b>비영속</b>: 아직 컨텍스트 밖. new 객체.</li>
        <li><b>영속</b>: <code>em.persist()</code> 또는 <code>find()</code>로 관리 상태.</li>
        <li><b>준영속</b>: <code>em.detach()</code>/<code>em.clear()</code>/트랜잭션 종료로 관리가 끊긴 상태.</li>
        <li><b>삭제</b>: <code>em.remove()</code> 호출.</li>
      </ul>

      <figure class="figure">
        <img src="/assets/notes/jpa/basics/SNAPSHOT-05-lifecycle.png" alt="엔티티 생명주기 다이어그램">
        <figcaption>엔티티 생명주기 다이어그램 (SNAPSHOT-05-lifecycle.png)</figcaption>
      </figure>

      <p>merge는 “준영속 객체를 살리는” 게 아니라, <i>새 영속 객체를 만들어 복사</i>하는 동작이다. 반환값을 쓰는 방식으로 해야 실수가 적었다.</p>

      <!-- 9. 트랜잭션 경계 & 지연 로딩 한 줄 메모 -->
      <h2 class="section">트랜잭션 경계 &amp; 지연 로딩 — 한 줄 메모</h2>
      <ul>
        <li>지연 로딩은 트랜잭션 경계 밖에서 초기화하려 하면 실패한다.</li>
        <li>출력계층(컨트롤러/뷰)에는 엔티티 대신 DTO를 전달하는 편이 사고가 적었다.</li>
      </ul>

      <!-- 10. 체크리스트 -->
      <h2 class="section">체크리스트</h2>
      <ul>
        <li>PK는 대리 키(Long) 우선. 비즈니스 키는 유니크 인덱스로.</li>
        <li>Enum은 STRING. 값 타입은 가능하면 불변.</li>
        <li>변경 감지/플러시/생명주기 동작은 <i>트랜잭션 경계 안</i>에서만 기대한다.</li>
        <li>대량 처리: flush/clear 주기 적용, SEQUENCE면 <code>allocationSize</code> 점검.</li>
      </ul>

      <p class="muted"><a href="/notes/">← Notes로 돌아가기</a></p>
    </article>
  </main>

  <!-- TOC 자동 생성 + 현재 섹션 동기화 -->
  <script>
  (function(){
    const article = document.querySelector('article.prose');
    if(!article) return;

    // h2/h3.section만 수집
    const headers = [...article.querySelectorAll('h2.section, h3.section')];

    const slugify = s => s.toLowerCase()
      .replace(/[^\p{Letter}\p{Number}\s-]/gu, '')
      .trim().replace(/\s+/g, '-').slice(0,64);

    headers.forEach(h => { if(!h.id) h.id = slugify(h.textContent); });

    const toc = document.getElementById('toc-list');
    toc.innerHTML = '';
    headers.forEach(h => {
      const li = document.createElement('li');
      if(h.tagName === 'H3') li.classList.add('level-3');
      const a = document.createElement('a');
      a.href = `#${h.id}`;
      a.textContent = h.textContent.trim();
      li.appendChild(a);
      toc.appendChild(li);
    });
  })();
  </script>
</body>
</html>
