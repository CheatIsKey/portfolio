<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>JPA 기본 개념 — spring-jpa.dev</title>
  <link rel="stylesheet" href="/styles.css" />
</head>
<body>
  <header class="site-header container">
    <a class="brand" href="/">spring-jpa.dev</a>
    <nav class="nav">
      <a href="/projects/">Projects</a>
      <a class="active" href="/notes/">Notes</a>
    </nav>
  </header>

  <main class="container article">
    <!-- 좌측: 자동 생성 목차 -->
    <aside class="toc" aria-label="Table of contents">
      <div class="toc-title">목차</div>
      <ul id="toc-list"></ul>
    </aside>

    <!-- 우측: 글 본문 -->
    <article class="prose">
      <h1>JPA 기본 개념 정리</h1>
      <p class="muted">작성일 2025-08-01 · 분류: Spring Boot, JPA</p>

      <!-- 1. 개요 -->
      <h2 class="section">개요</h2>
      <p>JPA(Java Persistence API)는 자바의 대표적인 ORM 표준이다. </p>
      <p>객체지향 언어와 관계형 데이터베이스 간의 불일치를 줄여주며,
         개발자는 SQL 작성보다 <b>객체 중심의 코드</b>에 집중할 수 있다.</p>
      <p>이 글에서는 JPA의 핵심 개념들을 간단히 정리한다. 이후에는 연관관계 매핑, Spring Data JPA, QueryDSL 등으로 확장할 예정이다.</p>

      <!-- 2. 엔티티 매핑 -->
      <h2 class="section">엔티티 매핑</h2>
      <ul>
        <li><code>@Entity</code> : JPA가 관리하는 클래스. 기본 생성자가 필요하다.</li>
        <li><code>@Table</code> : 매핑할 테이블 이름이나 제약조건을 설정한다.</li>
      </ul>
      <figure class="figure">
        <img src="/assets/notes/UserEntity.png" alt="User 객체">
        <figcaption>User 객체</figcaption>
      </figure>
      <p>주로 <code>@Id</code>와 <code>@GeneratedValue</code>를 통해 기본 키 전략을 설정한다. 대리 키(숫자 시퀀스, auto increment)를 일반적으로 사용한다고 한다.</p>

      <!-- 3. 필드와 컬럼 매핑 -->
      <h2 class="section">필드와 컬럼 매핑</h2>
      <ul>
        <li><code>@Column</code> : 길이, null 허용 여부, 컬럼명 등을 설정한다. </li>
        <li><code>@Enumerated(EnumType.STRING)</code> : Enum은 문자열 기반 매핑을 권장한다. ORDINAL로 설정하게 되면 인덱스 기준이 되므로, 순서가 변하면 결과도 완전히 달라진다.</li>
        <li><code>@Lob</code> : 게시글 내용처럼 대용량 문자/바이너리 매핑에 사용한다. </li>
        <li><code>@Transient</code> : 매핑을 제외한다. </li>
      </ul>
      <p>공통 속성은 <code>@Embeddable</code>과 <code>@Embedded</code>로 묶어낼 수 있다. (예: 주소)</p>

      <!-- 4. 영속성 컨텍스트 -->
      <h2 class="section">영속성 컨텍스트</h2>
      <p>JPA는 엔티티를 <b>영속성 컨텍스트</b>라는 1차 캐시에 보관한다.
         동일 트랜잭션 내에서는 같은 식별자를 가진 엔티티를 공유한다.</p>
      <ul>
        <li><b>동일성 보장</b> : 같은 엔티티를 조회하면 항상 같은 객체를 반환한다. </li>
        <li><b>변경 감지(Dirty Checking)</b> : 엔티티 필드를 수정하면 커밋 시 자동으로 UPDATE SQL을 생성한다. 즉, 따로 em.persist()를 할 필요가 없다. </li>
        <li><b>쓰기 지연</b> : INSERT/UPDATE SQL은 모아 두었다가 flush() 시점에 전송한다. </li>
      </ul>
      <p>객체를 조회했을 때, 영속성 컨텍스트에 없으면 디스크를 조회한 후 영속성 컨텍스트에 가져온다.</p>

      <!-- 5. 플러시 -->
      <h2 class="section">플러시(Flush)</h2>
      <p><b>flush()</b>는 영속성 컨텍스트의 변경 내용을 DB에 반영하는 동작이다. 단, 캐시는 비워지지 않기에 em.clear()를 수행하면 된다.</p>
      <ul>
        <li>트랜잭션 커밋 시 자동으로 호출된다. </li>
        <li>JPQL 실행 직전에 자동으로 호출된다. </li>
        <li>수동으로 <code>em.flush()</code> 호출이 가능하다. </li>
      </ul>
      
      <!-- 6. 엔티티 생명주기 -->
      <h2 class="section">엔티티 생명주기</h2>
      <p>엔티티는 아래와 같은 상태 전이를 거친다.</p>
      <ul>
        <li><b>비영속</b> : 아직 영속성 컨텍스트에 저장되지 않은 상태이다. (예: <code>em.persist()</code> 수행 전) </li>
        <li><b>영속(Dirty Checking)</b> : <code>em.persist()</code>로 관리되는 상태이다. </li>
        <li><b>준영속</b> : <code>em.detach()</code>, <code>em.clear()</code>, 트랜잭션 종료 등으로 더이상 엔티티 매니저가 관리하지 않는 상태이다. </li>
        <li><b>삭제</b> : <code>em.remove()</code>가 호출된 상태이다. </li>
      </ul>
      <p>준영속 상태에서는 변경 감지가 동작하지 않으며, 지연 로딩(proxy 초기화)도 실패할 수 있다. </p>

      <!-- 7. 정리 -->
      <h2 class="section">정리</h2>
      <ul>
        <li>JPA는 ORM 표준으로 객체-테이블 매핑과 영속성 컨텍스트 관리가 핵심이다.</li>
        <li>변경 감지(Dirty Checking), 쓰기 지연, 플러시 등을 통해 개발자는 SQL 대신 객체 작업에 집중할 수 있다.</li>
        <li>이후에는 연관관계 매핑, Spring Data JPA, QueryDSL 등을 이어서 학습할 예정이다.</li>
      </ul>

      <p class = "muted"> <a href="/notes/">← Notes로 돌아가기</a></p>
    </article>
  </main>
  <script>
  (function(){
    const article = document.querySelector('article.prose');
    if(!article) return;
    const headers = [...article.querySelectorAll('h2.section, h3.section')];
    const slugify = s => s.toLowerCase()
      .replace(/[^\p{Letter}\p{Number}\s-]/gu, '')
      .trim().replace(/\s+/g, '-').slice(0,64);
    headers.forEach(h => { if(!h.id) h.id = slugify(h.textContent) });
    const toc = document.getElementById('toc-list');
    toc.innerHTML = '';
    headers.forEach(h => {
      const li = document.createElement('li');
      if(h.tagName === 'H3') li.classList.add('level-3');
      const a = document.createElement('a');
      a.href = `#${h.id}`;
      a.textContent = h.textContent.trim();
      li.appendChild(a);
      toc.appendChild(li);
    });
  })();
  </script>
</body>
</html>
